---
title: Built-in Interceptors
description: Zypher Agent provides simple factory functions to create common interceptors. These handle the most frequent needs in agent development and can be used immediately without custom implementation.
---

## continueOnMaxTokens()

Automatically continues conversations when responses are truncated due to token limits:

```typescript
import { createZypherAgent, continueOnMaxTokens } from "@zypher/agent";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    continueOnMaxTokens(5), // Limit continuations (default: Infinity)
  ],
});
```

**How it works:**
- Monitors the `stopReason` from LLM responses
- When `stopReason` is `"max_tokens"`, returns `{ complete: false }` to continue the loop
- Prevents infinite loops by limiting maximum continuations
- The agent automatically receives a continuation prompt

**Common use cases:**
- **Long responses** - Automatically continue when agent responses are cut off
- **Complex tasks** - Allow agents to complete multi-step processes without manual intervention
- **Detailed explanations** - Ensure comprehensive responses aren't truncated

### Configuration Options

```typescript
continueOnMaxTokens(maxContinuations?: number)
// maxContinuations: Maximum continuations before stopping (default: Infinity)
```

## errorDetector()

Runs a command to detect errors and feeds them back to the agent for automatic fixing:

```typescript
import { createZypherAgent, errorDetector } from "@zypher/agent";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    errorDetector("deno", ["check", "."]),  // Type checking
    errorDetector("deno", ["lint"]),         // Linting
    errorDetector("deno", ["test"]),         // Tests
  ],
});
```

**How it works:**
1. After each agent response, runs the specified command
2. If the command fails (non-zero exit), injects error output into conversation
3. Agent sees errors and attempts to fix them
4. Loop continues until errors are resolved or max iterations reached

<Callout type="info" title="Interceptor Order">
Error detectors run in order. If the first detector finds errors, subsequent detectors won't run until those errors are fixed.
</Callout>

## Tool Execution (Automatic)

Tool execution is handled automatically by Zypher Agent. You don't need to add any interceptor for tools to work.

When the LLM requests a tool call:
1. Zypher automatically executes the tool
2. Results are added to the conversation
3. The loop continues for the agent to process results

## Combining Interceptors

Here's a complete example combining multiple interceptors:

```typescript
import {
  createZypherAgent,
  continueOnMaxTokens,
  errorDetector,
} from "@zypher/agent";
import { createFileSystemTools, RunTerminalCmdTool } from "@zypher/agent/tools";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  tools: [...createFileSystemTools(), RunTerminalCmdTool],
  config: {
    maxIterations: 25,
    maxTokens: 8192,
  },
  interceptors: [
    // Handle truncated responses
    continueOnMaxTokens(),

    // Type checking
    errorDetector("deno", ["check", "."]),

    // Linting
    errorDetector("deno", ["lint"]),
  ],
});

// Run a coding task - agent will automatically fix type/lint errors
const events$ = agent.runTask(
  "Add a new function to utils.ts that validates email addresses"
);

for await (const event of eachValueFrom(events$)) {
  if (event.type === "text") {
    process.stdout.write(event.content);
  }
  if (event.type === "interceptor_result") {
    console.log(`\n[${event.interceptorName}]: ${event.result.reason || "OK"}`);
  }
}
```

---

Built-in interceptors provide a solid foundation for agent control. For more advanced scenarios, learn about [creating custom interceptors](/zypher/core-concepts/loop-interceptors#custom-interceptors).
