---
title: Built-in Interceptors
description: Zypher Agent provides simple factory functions to create common interceptors. These handle the most frequent needs in agent development and can be used immediately without custom implementation.
---

## continueOnMaxTokens()

Automatically continues conversations when responses are truncated due to token limits:

```typescript
import { createZypherAgent, continueOnMaxTokens } from "@zypher/agent";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    continueOnMaxTokens(5), // Limit continuations (default: Infinity)
  ],
});
```

**How it works:**
- Monitors the `stopReason` from LLM responses
- When `stopReason` is `"max_tokens"`, returns `{ complete: false }` to continue the loop
- Prevents infinite loops by limiting maximum continuations
- The agent automatically receives a continuation prompt

**Common use cases:**
- **Long responses** - Automatically continue when agent responses are cut off
- **Complex tasks** - Allow agents to complete multi-step processes without manual intervention
- **Detailed explanations** - Ensure comprehensive responses aren't truncated

### Configuration Options

```typescript
continueOnMaxTokens(maxContinuations?: number)
// maxContinuations: Maximum continuations before stopping (default: Infinity)
```

## errorDetector()

Runs a command to detect errors and feeds them back to the agent for automatic fixing:

```typescript
import { createZypherAgent, errorDetector } from "@zypher/agent";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    // TypeScript/Deno type checking
    errorDetector("deno", ["check", "."]),

    // Linting
    errorDetector("deno", ["lint"]),

    // Node.js projects
    errorDetector("npm", ["run", "typecheck"]),
    errorDetector("npm", ["run", "lint"]),

    // Run tests
    errorDetector("npm", ["test"]),
  ],
});
```

**How it works:**
1. After each agent response, runs the specified command
2. If the command exits with a non-zero code, captures stderr/stdout
3. Returns `{ complete: false, reason: errorOutput }` to inject errors into conversation
4. Agent sees the errors and attempts to fix them
5. Loop continues until errors are resolved or max iterations reached
6. If command succeeds (exit code 0), returns `{ complete: true }`

### Common Error Detection Patterns

```typescript
// Deno projects
errorDetector("deno", ["check", "."]),        // Type checking
errorDetector("deno", ["lint"]),              // Linting
errorDetector("deno", ["test"]),              // Tests

// Node.js projects (npm)
errorDetector("npm", ["run", "build"]),       // Build
errorDetector("npm", ["run", "typecheck"]),   // TypeScript
errorDetector("npm", ["run", "lint"]),        // ESLint
errorDetector("npm", ["test"]),               // Tests

// Node.js projects (pnpm/yarn)
errorDetector("pnpm", ["typecheck"]),
errorDetector("yarn", ["lint"]),

// Python projects
errorDetector("python", ["-m", "mypy", "."]), // Type checking
errorDetector("python", ["-m", "pytest"]),    // Tests
errorDetector("ruff", ["check", "."]),        // Linting

// Rust projects
errorDetector("cargo", ["check"]),            // Type checking
errorDetector("cargo", ["clippy"]),           // Linting
errorDetector("cargo", ["test"]),             // Tests

// Go projects
errorDetector("go", ["build", "./..."]),      // Build
errorDetector("go", ["test", "./..."]),       // Tests
errorDetector("golangci-lint", ["run"]),      // Linting

// Custom scripts
errorDetector("./scripts/validate.sh", []),
errorDetector("make", ["check"]),
```

### Multiple Error Detectors

You can chain multiple error detectors. They run in order, and the first one to detect an error will trigger the agent to fix it:

```typescript
const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    // First check types
    errorDetector("deno", ["check", "."]),

    // Then check linting
    errorDetector("deno", ["lint"]),

    // Finally run tests
    errorDetector("deno", ["test"]),
  ],
});
```

<Callout type="info" title="Interceptor Order">
Error detectors run in the order you specify. If the first detector finds errors, subsequent detectors won't run until those errors are fixed. This creates a natural priority: fix type errors before lint errors, fix lint errors before running tests.
</Callout>

## Tool Execution (Automatic)

Tool execution is handled automatically by Zypher Agent. You don't need to add any interceptor for tools to work.

When the LLM requests a tool call:
1. Zypher automatically executes the tool
2. Results are added to the conversation
3. The loop continues for the agent to process results

### Tool Approval Handler

If you need to approve tools before execution, configure it in `createZypherAgent`:

```typescript
const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  tools: [...createFileSystemTools()],

  // Optional: Custom tool approval
  toolApprovalHandler: async (toolName, input, options) => {
    // Auto-approve safe tools
    const safeTools = ["read_file", "list_directory", "grep_search"];
    if (safeTools.includes(toolName)) {
      return true;
    }

    // Require approval for write operations
    console.log(`Tool: ${toolName}`);
    console.log(`Input: ${JSON.stringify(input, null, 2)}`);

    // Your approval logic here (prompt user, check policy, etc.)
    return await promptUserForApproval();
  },
});
```

### Tool Approval Patterns

```typescript
// Always approve (default behavior)
toolApprovalHandler: () => Promise.resolve(true),

// Interactive approval
toolApprovalHandler: async (name, input) => {
  const response = prompt(`Approve ${name}? (y/n)`);
  return response?.toLowerCase() === "y";
},

// Policy-based approval
toolApprovalHandler: async (name, input) => {
  const dangerousTools = ["run_terminal_cmd", "delete_file"];

  if (dangerousTools.includes(name)) {
    // Check command for dangerous patterns
    if (name === "run_terminal_cmd") {
      const cmd = (input as { command: string }).command;
      const blocked = ["rm -rf", "sudo", "format"];
      return !blocked.some((b) => cmd.includes(b));
    }
    return false; // Block other dangerous tools
  }

  return true; // Allow safe tools
},
```

## Combining Interceptors

Here's a complete example combining multiple interceptors:

```typescript
import {
  createZypherAgent,
  continueOnMaxTokens,
  errorDetector,
} from "@zypher/agent";
import { createFileSystemTools, RunTerminalCmdTool } from "@zypher/agent/tools";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  tools: [...createFileSystemTools(), RunTerminalCmdTool],
  config: {
    maxIterations: 25,
    maxTokens: 8192,
  },
  interceptors: [
    // Handle truncated responses
    continueOnMaxTokens(),

    // Type checking
    errorDetector("deno", ["check", "."]),

    // Linting
    errorDetector("deno", ["lint"]),
  ],
});

// Run a coding task - agent will automatically fix type/lint errors
const events$ = agent.runTask(
  "Add a new function to utils.ts that validates email addresses"
);

for await (const event of eachValueFrom(events$)) {
  if (event.type === "text") {
    process.stdout.write(event.content);
  }
  if (event.type === "interceptor_result") {
    console.log(`\n[${event.interceptorName}]: ${event.result.reason || "OK"}`);
  }
}
```

---

Built-in interceptors provide a solid foundation for agent control. For more advanced scenarios, learn about [creating custom interceptors](/zypher/core-concepts/loop-interceptors#custom-interceptors).
