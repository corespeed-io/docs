---
title: Loop Interceptors
description: Loop interceptors provide powerful control mechanisms for agent execution. They monitor agent behavior, detect problems, and can modify or halt execution when needed.
---

## What is the Agent Loop?

The core of agentic behavior is the **agent loop** - a continuous cycle where the agent:

1. **Receives/reviews messages** (user input, tool results, previous context)
2. **Reasons and generates a response** using the LLM
3. **Executes any tool calls** requested in the response
4. **Checks if the task is complete** or needs another iteration
5. **Repeats** until the task is finished or max iterations reached

This loop is what enables agents to think, act, observe results, and adapt their approach - the fundamental pattern of autonomous behavior.

## What are Loop Interceptors?

Loop interceptors are middleware components that run after each agent response to decide whether the loop should continue:

```text
Task Request ──▶ ┌─────────────┐ ── Agent Response ──▶ ┌─────────────────┐ ── Task Completed ──▶
                 │ Agent Loop  │                       │ LoopInterceptor │
                 └─────────────┘                       │    Pipeline     │
                       ▲                               └─────────────────┘
                       │                                        │
                       │                                   Continue
                       │                              (Inject more context)
                       │                                        │
                       └────────────────────────────────────────┘
```

Think of them as "decision gates" that:
- **Monitor** agent responses and behavior patterns
- **Detect** when intervention is needed (errors, security issues, token limits)
- **Inject feedback** by adding messages to guide the agent
- **Control flow** by deciding whether to continue the loop or finish the task
- **Enable complex behaviors** like tool execution, error handling, and validation

## Using Interceptors with createZypherAgent

The simplest way to add interceptors is through the `createZypherAgent` factory:

```typescript
import { createZypherAgent, errorDetector, continueOnMaxTokens } from "@zypher/agent";
import { createFileSystemTools } from "@zypher/agent/tools";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  tools: [...createFileSystemTools()],
  interceptors: [
    // Auto-continue when response is truncated
    continueOnMaxTokens(),

    // Run TypeScript type checking after each response
    errorDetector("deno", ["check", "."]),

    // Run linter after each response
    errorDetector("deno", ["lint"]),
  ],
});
```

<Callout type="info" title="Tool Execution is Automatic">
Tool execution (`executeTools()`) is **automatically prepended** to your interceptor chain. You don't need to add it manually - Zypher handles tool calls for you.
</Callout>

## Built-in Interceptor Functions

Zypher Agent provides simple functions to create common interceptors:

### `continueOnMaxTokens()`

Automatically continues when responses are truncated due to token limits:

```typescript
import { continueOnMaxTokens } from "@zypher/agent";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    continueOnMaxTokens({
      maxContinuations: 5, // Prevent infinite loops (default: 5)
    }),
  ],
});
```

### `errorDetector(command, args)`

Runs a command to detect errors and feeds them back to the agent:

```typescript
import { errorDetector } from "@zypher/agent";

const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    // TypeScript type checking
    errorDetector("deno", ["check", "."]),

    // Linting
    errorDetector("deno", ["lint"]),

    // Run tests
    errorDetector("npm", ["test"]),

    // Custom command
    errorDetector("./scripts/validate.sh", []),
  ],
});
```

**How it works:**
1. After each agent response, runs the specified command
2. If the command exits with an error, captures the output
3. Injects the error message back into the conversation
4. Agent sees the errors and can attempt to fix them
5. Loop continues until errors are resolved or max iterations reached

For detailed configuration and examples, see the [Built-in Interceptors](/zypher/core-concepts/loop-interceptors/built-in-interceptors) guide.

## How Interceptors Work

Interceptors run in registration order and each interceptor in the chain gets to examine the context and decide whether the agent should make another LLM request or finish the task.

**Key behaviors:**
- Interceptors are executed sequentially in registration order
- Each interceptor returns `{ complete: true }` or `{ complete: false, reason?: string }`
- **If any interceptor returns `complete: false`, execution stops and the agent makes another LLM request**
- Subsequent interceptors in the chain are **not executed** when an earlier interceptor returns `complete: false`
- Only if all interceptors return `complete: true` does the task finish
- Interceptors can provide a `reason` string which is injected as a user message

**What "continue" means:**
When an interceptor returns `{ complete: false, reason: "..." }`, the agent will make another call to the LLM with the reason injected as a user message. This allows interceptors to provide feedback that the agent can respond to.

### Interceptor Chain Behavior

```typescript
// If any interceptor returns complete: false, chain stops and agent makes new LLM request
SecurityInterceptor: { complete: false } → Chain stops, new LLM request

// If interceptor returns complete: true, chain continues to next interceptor
SecurityInterceptor: { complete: true } → ErrorDetector: { complete: true } → Task finishes

// First "continue" wins, subsequent interceptors are skipped
SecurityInterceptor: { complete: true } → ErrorDetector: { complete: false } → New LLM request
```

## Custom Interceptors

### Creating Your Own Interceptor

Build interceptors for domain-specific requirements:

```typescript
import type { LoopInterceptor, InterceptorContext, InterceptorResult } from "@zypher/agent";

const securityInterceptor = (): LoopInterceptor => ({
  name: "security",
  description: "Blocks potentially dangerous commands",

  intercept(context: InterceptorContext): InterceptorResult {
    const suspiciousPatterns = [/rm -rf/, /DROP TABLE/, /sudo/];

    // Check the last response for dangerous patterns
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(context.lastResponse)) {
        return {
          complete: false,
          reason: `Security Warning: Detected potentially dangerous command. Please use a safer alternative.`,
        };
      }
    }

    return { complete: true };
  },
});

// Use in agent
const agent = await createZypherAgent({
  model: "claude-sonnet-4-5-20250929",
  interceptors: [
    securityInterceptor(),
    errorDetector("deno", ["check", "."]),
  ],
});
```

### InterceptorContext

The context object provides access to:

```typescript
interface InterceptorContext {
  messages: Message[];           // Modifiable conversation history
  lastResponse: string;          // The agent's last text response
  tools: Tool[];                 // Available tools
  zypherContext: ZypherContext;  // Workspace context
  stopReason: string;            // Why the LLM stopped (end_turn, max_tokens, etc.)
  signal: AbortSignal;           // For cancellation
  eventSubject: Subject<TaskEvent>; // Emit custom events
}
```

### InterceptorResult

Return from your `intercept` function:

```typescript
interface InterceptorResult {
  complete: boolean;  // true = task done, false = continue loop
  reason?: string;    // Message to inject (when complete: false)
}
```

### Example: Haiku Validator

A fun example that validates the agent writes proper haikus:

```typescript
const haikuValidator = (): LoopInterceptor => ({
  name: "haiku_validator",
  description: "Validates haiku format (5-7-5 syllables)",

  intercept(context) {
    const lines = context.lastResponse.trim().split("\n");

    if (lines.length !== 3) {
      return {
        complete: false,
        reason: "A haiku must have exactly 3 lines. Please try again.",
      };
    }

    // Add syllable counting logic here...
    const isValid = validateSyllables(lines);

    if (!isValid) {
      return {
        complete: false,
        reason: "Your haiku doesn't follow the 5-7-5 syllable pattern. Try again.",
      };
    }

    return { complete: true };
  },
});
```

### Emitting Custom Events

Use `eventSubject` to emit custom events during interception:

```typescript
const metricsInterceptor = (): LoopInterceptor => ({
  name: "metrics",

  intercept(context) {
    // Emit custom event
    context.eventSubject.next({
      type: "interceptor_use",
      interceptorName: "metrics",
      timestamp: Date.now(),
    });

    return { complete: true };
  },
});
```

## Best Practices

### Interceptor Design

**Keep interceptors focused** - One responsibility per interceptor
```typescript
// Good: Focused on security
const securityInterceptor = () => ({ /* ... */ });

// Bad: Mixed responsibilities
const securityAndMetricsInterceptor = () => ({ /* ... */ });
```

**Use factory functions** - Return new instances for isolation
```typescript
// Good: Factory function
const errorDetector = (cmd: string, args: string[]) => ({
  name: "error_detector",
  intercept(ctx) { /* ... */ },
});

// Usage
interceptors: [errorDetector("deno", ["check", "."])]
```

**Order matters** - Security interceptors should come first
```typescript
interceptors: [
  securityInterceptor(),  // Check before errors
  errorDetector("deno", ["check", "."]),
  errorDetector("deno", ["lint"]),
]
```

---

Loop interceptors provide powerful control over agent behavior. Next, explore the [Built-in Interceptors](/zypher/core-concepts/loop-interceptors/built-in-interceptors) for detailed configuration options.
